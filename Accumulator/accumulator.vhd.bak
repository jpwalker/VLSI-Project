library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library work;
use work.types.all;
--use work.types.types_bdy;

entity accu_adder is
Port (IN_CHIP : IN std_logic_vector (31 downto 0);
--16 number of chips each with 2 bits 
	OUT_CHIP : OUT std_logic_vector (5 downto 0));
-- we need output of 6 bits
end accu_adder;

architecture accumulator of accu_adder is
type CHIP is array (31 downto 0) of bit;
-- 16 number of chips each with 2 bits so index numbers will be 32
subtype chip_value is bit_vector (1 downto 0);
-- each chip have 2 bits

--converted bits to 6 bit signed
type value_chip is array (-1 to 1) of integer;
-- integer range;
signal sgn : signed (5 downto 0);
-- integer of value_chip is defined in signed 6 bits
signal c0 : std_logic_vector (5 downto 0);
-- each chip have 2 bits defined as 6 bits as we need output of 6 bits
signal c1 : std_logic_vector (1 downto 0);
signal co1 : bit_vector (5 downto 0);
-- the feedback signal from output back to the input signal c1
function ret (c1 : std_logic_vector (0 to 5)) return bit_vector is
begin
return (co1);
end function;
signal c2 : std_logic_vector (5 downto 0);
variable chip_counter_ini : std_logic_vector(0 to 15) := 0;
--variable chip_counter_final : integer := 16;
Begin
sgn <= to_signed (i,6)
c0 <= std_logic_vector (sgn);
-- converting 2 bits to 6 bit signed
c1 <= std_logic_vector (sgn);
c1 := '000000';
-- initializing it to 0 in signed 6 bit format
c2 <= c0(5 downto 0);
-- moving the first 2 bits of the input to the signal
for chip_counter_ini in 0 to 15 loop
-- 16 number of chips
co1(5 downto 0) <= c2 or c1;
OUt_CHIP <= co1(5 downto 0);
chip_counter_ini := chip_counter_ini + 1;
end loop;
--chip_counter_ini := chip_counter_ini + 1;
-- incrementing the count of chip 
c0 <= IN_CHIP + 2;
-- each chip is of 2 bits so for next chip incrementing by 2 and moving the signal

-- storing the previous value of the output
end accumulator;